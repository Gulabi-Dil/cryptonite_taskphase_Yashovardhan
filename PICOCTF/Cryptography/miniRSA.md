# Description:
Let's decrypt this: `ciphertext`? Something seems a bit small.

The provided attachment's contents:
```
N: 29331922499794985782735976045591164936683059380558950386560160105740343201513369939006307531165922708949619162698623675349030430859547825708994708321803705309459438099340427770580064400911431856656901982789948285309956111848686906152664473350940486507451771223435835260168971210087470894448460745593956840586530527915802541450092946574694809584880896601317519794442862977471129319781313161842056501715040555964011899589002863730868679527184420789010551475067862907739054966183120621407246398518098981106431219207697870293412176440482900183550467375190239898455201170831410460483829448603477361305838743852756938687673
e: 3

ciphertext (c): 2205316413931134031074603746928247799030155221252519872649649212867614751848436763801274360463406171277838056821437115883619169702963504606017565783537203207707757768473109845162808575425972525116337319108047893250549462147185741761825125 
```
# Hints:
- RSA [tutorial](https://en.wikipedia.org/wiki/RSA_(cryptosystem))
# Solution:
From the wikipedia link, I got the formula which is used in RSA encryption: **$c \equiv m^{e} \pmod{n}$** where c is the ciphertext, m is the plaintext or original text, e is the public key exponent and n is the modulus.
When N>e, this expression is equivalent to c=m^{e}. Here, e=3. So, I wrote a script for this cube root attack.
```
import math
C=2205316413931134031074603746928247799030155221252519872649649212867614751848436763801274360463406171277838056821437115883619169702>e=3
def eth_root(n):
  l=0
  u=n
  while (l<=u):
    m=(l+u)//2
    root=m**3
    if(root==C):
      return m
    elif(root>n):
      u=m-1
    else:
      l=m+1
print(eth_root(C))
print(bytes.decode(bytes.fromhex(hex(eth_root(C))[2:])))
```
Output:
```
13016382529449106065894479374027604750406953699090365388202874238148389207291005
picoCTF{n33d_a_lArg3r_e_606ce004}
```

Another new method I learnt and figured out:
```
yasho@DESKTOP-6ND4URA:~$ python3
Python 3.10.12 (main, Nov  6 2024, 20:22:13) [GCC 11.4.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> import sympy as s
>>> c=2205316413931134031074603746928247799030155221252519872649649212867614751848436763801274360463406171277838056821437115883619169702963504606017565783537203207707757768473109845162808575425972525116337319108047893250549462147185741761825125
>>> s.root(c,3)
13016382529449106065894479374027604750406953699090365388202874238148389207291005
>>> cuberoot=s.root(c,3)
>>> bytes.decode(bytes.fromhex(hex(cuberoot)[2:]))
'picoCTF{n33d_a_lArg3r_e_606ce004}'
```
Pretty quick and efficient!
# Flag:
>picoCTF{n33d_a_lArg3r_e_606ce004}

# Incorrect methods:
Initially I was trying to find the root by doing math.pow(c,1/3) which kept on giving me different roots which I realized prettyyy late. The reason for this is that 1/3 is a non terminating decimal and thus its value seems to be taken differently each time, hence the incorrect root.
